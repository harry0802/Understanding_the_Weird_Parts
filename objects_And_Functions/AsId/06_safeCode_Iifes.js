/*
   執行堆
   1. 當程式第一次載入會創建程式的全域執行環境
   2. 在一開始的時候並沒有任何變數名和函數被提升
   3. 然後到了 匿名立即函數時，當他到了函數表達式的時後，全域執行環境會創造函數物件記憶體，匿名的沒有名稱， 所以這是個物件有這些程式碼。
   4. 之後看到了呼叫函數的括號（），一個新的執行環境被創造，給這個匿名函數，函數內的程式被逐行執行， 
*/ 
/*
    在函數裡面宣告的變數會進入到函數的執行環的境變數環境中，並不是全域環境因為我們在執行一個函數，他有自己的執行環境。
    任何在函數裡面宣告變數，都會創建在函數的執行環境裡面，不會接觸到全域環境。
    當我們創造可以重複利用的東西時，可以利用這樣確保程式不會與其他程式互相衝突，讓我們不會不小心把東西放在全域物件。
    但如果我們要傳入全物物件的東西時也可以，因為物件是傳參考，包括函數物件。
    所以當我們想要取用全域物件，就只需要傳入函數參考就好。
*/ 
var a =10;
console.log(a + ' 全域執行環境');
(function(name){
    var a = 1;
    console.log('hi '+ name + ' 我是匿名立即函數');
    console.log(a)
}('大聰明'));
console.log(a);
console.log('------------');
// 取用全域物件
(function (global, name){
    var a = 1;
    /*
    因為參考傳入 window ，所以將會覆寫 全域對象的變數，函數對象的變數不受影響
    所以我們在函數物件裡面想要去使用到全物物件的東西，就可以利用參考去連接到全域對象
    但這樣會影響全域物件，請在清楚自己在做什麼的狀態下使用
    */ 
    global.a = 99;
    var gloa = global.a;
    console.log(' 函數執行環境 ' + 'hi '+ name + ' 我是匿名立即函數');
    console.log(a + ' 函數執行環境 ' +' 函數物件的變數')
    console.log(gloa + ' 函數執行環境 ' + ' 改變全域物件的變數')
}(window ,'小聰明'));
console.log('------------------');
console.log('全域物件被IIFE改變後');
console.log(a + ' 全域執行環境');