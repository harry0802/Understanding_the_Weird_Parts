/*
    byValue_And_byReference:
    討論的是關於變數的東西

    * Reference 參考：
        物件
        是到記憶體的位置
        所以 a 與 b 都參考到相同的地址，a並不會被新創建一個對象 
        所有的物件都是 Reference ，當用等號運算子時。

    * byValue 值
        純值
        傳入或設定這個值成為 另一個值的複製，因此兩個變數就一樣了
        例如：
        a = b;
        * 設定了一個新的值是 b ， 而 b 傳入了一個函數，而這個函數是 a 
         a 的變數會指向一個新的位址，一個新的記憶體地點，
         而 b 的純值會被複製放在 記憶體裡面。
        * 如果 b = 3 , 他會在一個位址，一個記憶體中的地點
         那麼 a 會指向3 然後複製這個地點，會被填上相同的值


*/ 
    
/*
    byValue (primitives) pri-mə-tiv:
    當 b 被設定為 a 等號運算子，創造了新的記憶體位址給 a ，複製了 b 的值給 a 的位址 ， 所以 a = 3 , b = 3;
    他們是對方的複製，在兩個不同的記憶體位置，所以可以改變 b 的值而不引響 a，因為他們是兩個記憶體不同的點
    a =b 他只是單純複製他的值便結束， 
*/ 
   var b =3;
   var a =b;

/*
    Reference (all objects / including (function))
    * c 指向了一個新的記憶體地址，
    * 而 d = c ;等號運算子知道他們是物件，所以他並不會創建一個新的記憶體地址給 d 
      而是複製 c 的記憶體地址，讓他們指向同一個記憶體物件。
    * 他並不是複製了一個新的值，而是他指向了同一個記憶體位址
    * 由於物件指向一個記憶體位址，所以只要改變其中一個值，其他所有指向同一個記憶體位址的物件，變數都會改變。
*/ 

    var c = { a:1 };
    var d = c;
    c.a2 =  '把你揚瞜';
/*
    mutate：
    * 改變某件事
    * 所以當新增值或屬性，刪除值等等 只要是改變當下的操作 就是稱為 mutate
    immutable： 
    不可改變某件事
*/ 

/*
    Reference 對函數也是一樣
    * 就算是參數也是經過 Reference（參考） 傳入。
    * 就像等號運子一樣，物件傳入了函數中的參考點（obj），所以 obj 會指向了 d 的記憶體位址
      而 d 指向了 c 的記憶體位址

*/
    function f1(obj){
        obj.a3 = '開玩笑的啦'
    }
    f1(d);
    console.log(c)
    console.log(d)

/*
    等號運算子會創建一個新的記憶體空間，也就是新的記憶體位置
     c = {g1: '猜猜我是誰' }; 
     等於創建了新的記憶體位址給了c，d就不再和他指向同一個記憶體位址
*/ 
    c = {g1: '猜猜我是誰' };
    console.log(c)
    console.log(d)
    